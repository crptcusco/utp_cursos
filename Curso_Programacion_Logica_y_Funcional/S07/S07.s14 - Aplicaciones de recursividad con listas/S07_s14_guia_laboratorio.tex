\documentclass[12pt]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{amsmath}
\usepackage{booktabs}

\geometry{a4paper, margin=2.5cm}

% Colores para código
\definecolor{codebg}{RGB}{245,245,245}
\definecolor{keyword}{RGB}{0,0,180}
\definecolor{comment}{RGB}{0,120,0}
\definecolor{string}{RGB}{160,0,0}

% Configuración listings mejorada (notación Haskell correcta)
\lstset{
  language=Haskell,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{codebg},
  keywordstyle=\color{keyword}\bfseries,
  commentstyle=\color{comment},
  stringstyle=\color{string},
  numbers=none,
  frame=single,
  framesep=8pt,
  rulecolor=\color{blue!30},
  showstringspaces=false,
  breaklines=true,
  captionpos=b,
  literate={->}{{$\rightarrow$}}2 {\\}{{$\lambda$}}1
}

% Caja para ejercicios
\newtcolorbox{ejercicio}[1]{
  colback=white,
  colframe=blue!50!black,
  fonttitle=\bfseries,
  title=#1,
  boxsep=5pt,
  arc=4pt,
  breakable
}

% Caja para soluciones
\newtcolorbox{solucion}[1]{
  colback=green!5!white,
  colframe=green!50!black,
  fonttitle=\bfseries,
  title=#1,
  boxsep=5pt,
  arc=4pt,
  breakable
}

\title{\textbf{Guía de Laboratorio – Sesión 14}\\Recursividad con Listas y Aplicaciones}
\author{Docente: Carlos R. P. Tovar}
\date{Ciclo 2025-2}

\begin{document}
\maketitle

\section*{Objetivos}
\begin{itemize}
  \item Comprender la aplicación de la recursividad en listas.
  \item Implementar funciones recursivas para operaciones básicas.
  \item Resolver problemas prácticos utilizando listas en Haskell.
  \item Analizar la complejidad de funciones recursivas.
\end{itemize}

\section*{Requisitos Previos}
\begin{itemize}
  \item Instalación de GHC/GHCi (The Glasgow Haskell Compiler)
  \item Conocimiento básico de sintaxis de Haskell y pattern matching
  \item Comprensión de tipos de datos básicos y listas
  \item Familiaridad con el concepto de recursividad simple
\end{itemize}

\section*{Conceptos Clave}
\begin{itemize}
  \item Una función recursiva sobre listas siempre tiene:
    \begin{itemize}
      \item Caso base (lista vacía \texttt{[]})
      \item Llamada recursiva (procesa la cola de la lista \texttt{xs})
    \end{itemize}
  \item La recursividad reemplaza los bucles tradicionales
  \item Esquema general:
\begin{lstlisting}
funcion :: [a] -> b
funcion []     = ...      -- Caso base
funcion (x:xs) = ... x ... funcion xs ...  -- Caso recursivo
\end{lstlisting}
\end{itemize}

\section*{Ejercicios Resueltos}

\begin{ejercicio}{1. Suma de elementos de una lista}
\begin{lstlisting}
suma :: [Int] -> Int
suma []     = 0
suma (x:xs) = x + suma xs

-- Pruebas
-- suma [1,2,3,4]  => 10
-- suma []         => 0
\end{lstlisting}
\end{ejercicio}

\begin{ejercicio}{2. Conteo de elementos de una lista}
\begin{lstlisting}
contar :: [a] -> Int
contar []     = 0
contar (_:xs) = 1 + contar xs

-- Pruebas
-- contar [5,10,15]     => 3
-- contar ["a","b","c","d"] => 4
\end{lstlisting}
\end{ejercicio}

\begin{ejercicio}{3. Buscar un elemento en una lista}
\begin{lstlisting}
buscar :: Eq a => a -> [a] -> Bool
buscar _ [] = False
buscar e (x:xs)
    | e == x    = True
    | otherwise = buscar e xs

-- Pruebas
-- buscar 3 [1,2,3,4] => True
-- buscar 5 [1,2,3,4] => False
\end{lstlisting}
\end{ejercicio}

\begin{ejercicio}{4. Invertir una lista}
\begin{lstlisting}
invertir :: [a] -> [a]
invertir []     = []
invertir (x:xs) = invertir xs ++ [x]

-- Pruebas
-- invertir [1,2,3] => [3,2,1]
-- invertir "Haskell" => "lleksaH"
\end{lstlisting}
\textbf{Nota:} Esta implementación es ineficiente (O(n²)). Versión más eficiente:
\begin{lstlisting}
invertirEficiente :: [a] -> [a]
invertirEficiente xs = invertirAux xs []
  where
    invertirAux []     acum = acum
    invertirAux (y:ys) acum = invertirAux ys (y:acum)
\end{lstlisting}
\end{ejercicio}

\begin{ejercicio}{5. Máximo de una lista}
\begin{lstlisting}
maximo :: Ord a => [a] -> a
maximo [x]    = x
maximo (x:xs) = max x (maximo xs)

-- Pruebas
-- maximo [2,7,5,9,3] => 9
-- maximo [42]        => 42
\end{lstlisting}
\textbf{Nota:} Esta función falla con lista vacía. Versión segura:
\begin{lstlisting}
maximoSeguro :: Ord a => [a] -> Maybe a
maximoSeguro []     = Nothing
maximoSeguro [x]    = Just x
maximoSeguro (x:xs) = case maximoSeguro xs of
                        Just y  -> Just (max x y)
                        Nothing -> Just x
\end{lstlisting}
\end{ejercicio}

\begin{ejercicio}{6. Filtrar elementos pares}
\begin{lstlisting}
pares :: [Int] -> [Int]
pares [] = []
pares (x:xs)
    | even x    = x : pares xs
    | otherwise = pares xs

-- Pruebas
-- pares [1,2,3,4,5,6] => [2,4,6]
\end{lstlisting}
\end{ejercicio}

\begin{ejercicio}{7. Concatenar lista de listas}
\begin{lstlisting}
concatenar :: [[a]] -> [a]
concatenar [] = []
concatenar (xs:xss) = xs ++ concatenar xss

-- Pruebas
-- concatenar [[1,2],[3,4],[5]] => [1,2,3,4,5]
\end{lstlisting}
\end{ejercicio}

\begin{ejercicio}{8. Aplanar lista de listas (usando foldr)}
\begin{lstlisting}
aplanar :: [[a]] -> [a]
aplanar = foldr (++) []

-- Pruebas
-- aplanar [[1,2],[],[3,4]] => [1,2,3,4]
\end{lstlisting}
\end{ejercicio}

\section*{Análisis de Complejidad}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Función} & \textbf{Complejidad Temporal} & \textbf{Complejidad Espacial} \\
\midrule
\texttt{suma} & O(n) & O(n) \\
\texttt{contar} & O(n) & O(n) \\
\texttt{buscar} & O(n) & O(n) \\
\texttt{invertir} & O(n²) & O(n) \\
\texttt{invertirEficiente} & O(n) & O(1) \\
\texttt{maximo} & O(n) & O(n) \\
\texttt{pares} & O(n) & O(n) \\
\texttt{concatenar} & O(m) & O(m) \\
\texttt{aplanar} & O(m) & O(1) \\
\bottomrule
\end{tabular}
\caption{Complejidad de las funciones implementadas (n = tamaño lista, m = total elementos)}
\end{table}

\section*{Ejercicios Propuestos}
\begin{itemize}
  \item Implementar una función recursiva que elimine todas las ocurrencias de un número en una lista.
  \item Definir una función que cuente cuántos números pares hay en una lista.
  \item Crear una función que calcule el producto de todos los elementos de una lista.
  \item Escribir una función que obtenga el mínimo de una lista de enteros.
  \item Implementar una función que sume únicamente los números impares de una lista.
  \item Crear una función que verifique si una lista está ordenada ascendentemente.
  \item Implementar una función que devuelva los primeros n elementos de una lista.
  \item Escribir una función que elimine elementos duplicados consecutivos.
  \item Implementar la función \texttt{takeWhile} de forma recursiva.
  \item Crear una función que aplique una función a cada elemento de una lista (como \texttt{map}).
\end{itemize}

\section*{Depuración de Funciones Recursivas}
\begin{itemize}
  \item \textbf{Usar \texttt{Debug.Trace}:}
\begin{lstlisting}
import Debug.Trace

sumaDebug :: [Int] -> Int
sumaDebug [] = trace "Caso base: []" 0
sumaDebug (x:xs) = trace ("Procesando: " ++ show x) (x + sumaDebug xs)
\end{lstlisting}

  \item \textbf{Verificar siempre el caso base}
  \item \textbf{Probar con casos límite:}
    \begin{itemize}
      \item Lista vacía \texttt{[]}
      \item Lista con un elemento \texttt{[x]}
      \item Lista con dos elementos \texttt{[x,y]}
    \end{itemize}
  \item \textbf{Usar tipos de datos apropiados} (\texttt{Maybe} para posibles fallos)
\end{itemize}

\section*{Soluciones Sugeridas para Ejercicios Propuestos}

\begin{solucion}{Eliminar ocurrencias de un elemento}
\begin{lstlisting}
eliminar :: Eq a => a -> [a] -> [a]
eliminar _ [] = []
eliminar e (x:xs)
  | x == e    = eliminar e xs
  | otherwise = x : eliminar e xs

-- Prueba: eliminar 3 [1,3,2,3,4] => [1,2,4]
\end{lstlisting}
\end{solucion}

\begin{solucion}{Contar números pares}
\begin{lstlisting}
contarPares :: [Int] -> Int
contarPares [] = 0
contarPares (x:xs)
  | even x    = 1 + contarPares xs
  | otherwise = contarPares xs

-- Prueba: contarPares [1,2,3,4,5,6] => 3
\end{lstlisting}
\end{solucion}

\begin{solucion}{Producto de elementos}
\begin{lstlisting}
producto :: [Int] -> Int
producto [] = 1
producto (x:xs) = x * producto xs

-- Prueba: producto [1,2,3,4] => 24
\end{lstlisting}
\end{solucion}

\begin{solucion}{Mínimo de una lista}
\begin{lstlisting}
minimo :: Ord a => [a] -> Maybe a
minimo [] = Nothing
minimo [x] = Just x
minimo (x:xs) = case minimo xs of
                 Just y  -> Just (min x y)
                 Nothing -> Just x

-- Prueba: minimo [3,1,4,2] => Just 1
\end{lstlisting}
\end{solucion}

\begin{solucion}{Implementación de map}
\begin{lstlisting}
miMap :: (a -> b) -> [a] -> [b]
miMap _ []     = []
miMap f (x:xs) = f x : miMap f xs

-- Prueba: miMap (*2) [1,2,3] => [2,4,6]
\end{lstlisting}
\end{solucion}

\section*{Formato de Entrega}
\begin{itemize}
  \item Subir archivo \texttt{Sesion13.hs} con todas las funciones implementadas
  \item Incluir capturas de pantalla con pruebas en GHCi
  \item Comentar el código explicando cada caso (base y recursivo)
  \item Incluir análisis de complejidad para cada función
\end{itemize}

\section*{Conclusiones}
\begin{itemize}
  \item La recursividad es la herramienta fundamental para manipular listas en Haskell
  \item Permite definir funciones expresivas y declarativas sin efectos secundarios
  \item Refuerza la abstracción y prepara para estructuras de datos más complejas
  \item El análisis de complejidad ayuda a optimizar el código
  \item La práctica con casos límite mejora la robustez de las implementaciones
\end{itemize}

\section*{Próxima Sesión}
\begin{itemize}
  \item \textbf{Tema:} Evaluación perezosa y listas infinitas
  \item \textbf{Preparación:} Investigar sobre \texttt{map}, \texttt{filter} y \texttt{fold}
  \item \textbf{Ejercicio avanzado:} Implementar \texttt{takeWhile} de forma recursiva
\end{itemize}

\end{document}