"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var prettier = __toESM(require("prettier"));
var import_parser = require("./parser");
var import_utils = require("./utils");
const b = prettier.doc.builders;
const languages = [
  {
    extensions: [".styl"],
    name: "Stylus",
    parsers: ["stylus"]
  }
];
const AST_FORMAT = "postcss-stylus-ast";
const parsers = {
  stylus: {
    parse: import_parser.parse,
    astFormat: AST_FORMAT,
    locStart: () => {
      throw new Error();
    },
    locEnd: () => {
      throw new Error();
    }
  }
};
function block(doc) {
  return b.indent([
    b.hardline,
    b.join(b.hardline, Array.isArray(doc) ? doc : [doc])
  ]);
}
const printStylus = (path, options, print) => {
  var _a, _b;
  const node = path.getValue();
  const children = (_, prop) => path.map(print, prop);
  const child = (_, prop) => path.call(print, prop);
  switch (node.nodeName) {
    case "root":
      return [b.join(b.hardline, children(node, "nodes")), b.hardline];
    case "group": {
      return [
        b.join(b.hardline, children(node, "nodes")),
        child(node, "block")
      ];
    }
    case "selector": {
      return children(node, "segments");
    }
    case "block": {
      return block(children(node, "nodes"));
    }
    case "property": {
      const value = node.expr.nodes[0];
      const sep = value.nodeName === "ident" && !(0, import_utils.isSingleIdent)(value) ? ": " : " ";
      return [children(node, "segments"), sep, child(node, "expr")];
    }
    case "expression": {
      const parent = path.getParentNode();
      const grandparent = path.getParentNode(1);
      const isUrl = (grandparent == null ? void 0 : grandparent.nodeName) === "call" && grandparent.name === "url";
      const isCompound = ((_a = node.nodes[0]) == null ? void 0 : _a.nodeName) === "expression";
      const separator = isUrl ? "" : isCompound ? ", " : " ";
      const content = b.join(separator, children(node, "nodes"));
      if ((parent == null ? void 0 : parent.nodeName) === "selector" || (parent == null ? void 0 : parent.nodeName) === "keyframes") {
        return ["{", content, "}"];
      }
      return content;
    }
    case "binop": {
      return [child(node, "left"), " ", node.op, " ", child(node, "right")];
    }
    case "unaryop": {
      return [node.op, "(", child(node, "expr"), ")"];
    }
    case "each": {
      return [
        "for ",
        node.val,
        ...node.key ? [", ", node.key] : [],
        " in ",
        child(node, "expr"),
        child(node, "block")
      ];
    }
    case "call": {
      return [node.name, child(node, "args")];
    }
    case "params":
    case "arguments": {
      return ["(", b.join(", ", children(node, "nodes")), ")"];
    }
    case "function": {
      return [node.name, child(node, "params"), child(node, "block")];
    }
    case "unit":
      return `${node.val}${(_b = node.type) != null ? _b : ""}`;
    case "ident":
      if ((0, import_utils.isSingleIdent)(node)) {
        return `${node.property ? "@" : ""}${node.string}${node.rest ? "..." : ""}`;
      } else {
        if (node.val.nodeName === "function") {
          return child(node, "val");
        }
        return [node.name, " = ", child(node, "val")];
      }
    case "literal":
      return typeof node.string === "string" ? node.string : child(node, "string");
    case "string":
      return [`'`, node.string, `'`];
    case "comment":
      if (node.str.includes(import_parser.BLANK_LINE_PLACEHOLDER)) {
        return "";
      }
      return node.str;
    case "rgba":
      return node.raw.trim();
    case "keyframes":
      return [
        "@keyframes ",
        children(node, "segments"),
        child(node, "block")
      ];
    case "media":
      return ["@media ", child(node, "val"), child(node, "block")];
    case "querylist":
      return b.join(", ", children(node, "nodes"));
    case "query":
      return [
        node.resolvedPredicate ? node.resolvedPredicate + " " : "",
        node.resolvedType ? node.resolvedType + " and " : "",
        b.join(" and ", children(node, "nodes"))
      ];
    case "feature":
      return ["(", children(node, "segments"), ": ", child(node, "expr"), ")"];
    case "import":
      return [
        `@${node.once ? "require" : "import"} `,
        `'${node.path.nodes[0].string}'`
      ];
    case "atrule":
      return ["@" + node.type, child(node, "block")];
    case "object":
      const fields = [];
      for (const key in node.vals) {
        const isLast = Object.keys(node.vals).indexOf(key) === node.length - 1;
        const value = path.call(print, "vals", key, "first");
        fields.push([
          key,
          ": ",
          value,
          options.trailingComma !== "none" || !isLast ? "," : ""
        ]);
      }
      return ["{", block(fields), b.hardline, "}"];
    case "member":
      return [child(node, "left"), ".", child(node, "right")];
    default:
      console.error(node);
      throw new Error(node.nodeName + " is not supported yet");
  }
};
const printers = {
  [AST_FORMAT]: {
    print: printStylus
  }
};
module.exports = {
  languages,
  parsers,
  printers
};
//# sourceMappingURL=index.js.map
